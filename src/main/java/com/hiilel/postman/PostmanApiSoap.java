package com.hiilel.postman;

public class PostmanApiSoap {
    /*
    Rest це архітектурний стиль використання як ми приймаємо запити які файли Json XML і тд тільки http/https
    може бути закеширований
    Simple
    Reliable
    Visible
    Scalable
    Upgradable
    Easy to maintain
    Restful це структура яка відповідає методу Rest
    GET - це select в бд
    POST - це новий запис в бд (insert)
    PUT - це обновити повністю весь об'єкт (update в бд)
    PATCH - це обновити частково (update в бд)
    DELETE - це видалити (delete в бд)

    Soap це протокол яка приймає тільки XML проте може використовувати різні протоколи
    не може бути закеширований
    Json це JS object notation - типу як ми записуємо як об'єкт - змінні(ключ) та їх значення,(ключ){"name" : "Юра"}
    може приймати до себе []масиви , "стрінги" , int 2412321
    Rest проти Soap - простота проти правил
    Rest - швидкість, підтримка різних форматів можна зі Swagger дістати всі запити
    Soap - більше можливостей щодо безпеки також вже є WSDL- образци запросов
    GraphQL - мова запитів для API, апк  швидші і стабільні тому що вони самі контролюють data яку отримують а не сервер
    також можна отримувати данні з різних endpoint
    REST - недоліки over fetching тобто endpoint завжди повертає всі поля
    under fetching - тобто нам потрібно робити додаткові запити для того щоб отримати інформацію яка нам потрібна 
    Потрібна документація щоб зрозуміти які типи даних в полях int string і тд


    1. Хороша практика endpoints , створити один і використовувати різні методи
    створити users як загальний потім через наступний endpoint зробити його багатофункціональним
    /users метод GET отримати всіх юзерів
    /users/123 метод GET отримати юзера з id 123
    /users POST створює нових юзерів
    так через один endpoint можна робити багато дій
    створювати багато endpoint /createuser /deleteuser /updateuser не правильно
    2. Також краще не добавляти не потрібно методу для endpoint (якщо в умові тільки get а дев добавив всі методи
     на майбутнє краще про це сказати так як тестування всіх займе більше часу)
    3. Використання версій v1 v2 v3  потрібно приклад з нашими tokens ідеально
    4. Використання коректних статус кодів не повертати 200 а в тілі вже писати контекст помилки
    5. Використання валідації на API також (5 полей 3 обов'язкові і пробувати не через ui а через запити) також
    при інтеграції api коли один api передає дані іншому api щоб не було пустих або не правильно заповнених полей
    на бекенді приклад наш бекенд який створює аккаунт в shopify щоб він передавав саме всі потрібні поля і щоб
    інфа була коректна
    Також валідація значень максимальних мінімальних
    6. Error handling and Status Response Messages
    6.1 Використовувати правильні status code
    Наприклад неправильний пароль а ми повертаємо 403 (помилка коли юзер є в базі даних але в нього немає прав щоб
    використати цей endpoint це не правильний status code)
    повинна бути 401 status code (не авторизований тобто що не знайшли такого юзера
    6.2 НЕ використовувати stack trace тому що там буде видно які класи за що відповідають не секьюрно
    6.3 Описувати помилки самим
    7. Використовувати httpS - данні в криптованому вигляді , http в відкритому вигляді
    Можна перехопити JVD токен і розпарсити його і получити клієнтську інформацію sensitive data (якщо http)
    і також з точки безпеки обмежити к-сть запитів з одного host'a щоб не дедосили ваш сервер
    8. Documentation завжди бути впевненим що всі наші нові зміни чи новий функціонал задокументовані (Swagger)
    Api testing process
    1.Test planing
    2.Test monitoring and control
    3.Test analysis
    4.Test design
    5.Test implementation
    6.Test execution
    7.Test completion
    Api тестування також допомагає хендлети ерорки що не завжди можливо при ui
    Types of API test
    1 Functional
    1.1 Відповідає документації
    1.1.1 Дає описану в документації відповідь на надіслані запити
    1.1.2 Змінює наш стейт app наприклад переходить на наступну сторінку і тд
    1.1.3 Хендлить помилки коли результат за межами очікуваних параметрів
    1.2 Включає позитивне та негативне тестування
    2 NON-functional
    2.1 Performance перевірка що немає такого що замало пам'яті а йде scale сервера
    2.2 Load
    2.3 Stress
    2.4 Endurance витривалість
    2.2 Security - не передаємо сeнсетів інфо від юзера або той самий stack trace
    2.3 Documentation
    Які ендпоінти беремо
    Які методи в кожного ендпоінта
    Валідний body як виглядає
    Які хедери будемо використовувати
    Success response code and body
    Error cases
    3 Change Based (основані на зміннах в функціональності)
    Test scenarios
    1 Happy path basic positive tests (набір мінімальних даних які повинен мати запит)
    2 Extended positive testing with optional parameters ( Додаткові не обов'язкові поля)
    3 Negative testing with valid input (наприклад у вас має бути унікальне ім'я а ви використовуєте не
    унікальне але валідне ім'я) або повторюванні email і тд
    4 Negative testing with invalid input (тобто всі символи або пробіли на фронті або < від мінімальних
    > від максимальних, або пусту форму відправити) ( з API те саме що ми перевіряємо валідні дані полів так само як на
    фронті)
    5 Auth and permissions tests 401 403 помилки авторизації та доступів
    6 Performance tests
    7 Test documentation






     */
}
